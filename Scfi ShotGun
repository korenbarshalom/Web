using UnityEngine;
using System.Collections;
using TMPro; // ✅ TextMeshPro

public class TripleShooter : MonoBehaviour
{
    [Header("Bullet Settings")]
    public GameObject bulletPrefab;
    public Transform firePoint;
    public float bulletSpeed = 50f;
    public float spreadAngle = 10f;
    public float bulletMaxDistance = 20f;
    public Transform bulletContainer;

    [Header("Fire Settings")]
    public float fireRate = 0.25f;
    private float nextFireTime = 0f;
    private int shotsFired = 0;

    [Header("Twist Settings")]
    public float twistAmount = 0.5f;
    public float twistFrequency = 2f;

    [Header("Shoot Animation Settings")]
    public Transform shootAnimationObject;
    public float recoilAngle = 6f;
    public float recoilDuration = 0.1f;

    [Header("Reload Settings")]
    public Transform reloadAnimationObject;
    public float reloadDistance = 0.3f;
    public float reloadDuration = 0.3f;

    [Header("Sound Settings")]
    public AudioSource shootAudioSource;
    public AudioClip shootSoundClip;
    public AudioSource reloadAudioSource;
    public AudioClip reloadSoundClip;

    [Header("Ammo Settings")]
    public int maxAmmoPerMagazine = 2;
    public int currentAmmo = 2;
    public int magazines = 6;
    public TextMeshProUGUI ammoText;

    [Header("Muzzle Flash Settings")]
    public ParticleSystem muzzleFlash;

    [Header("Robot Destroy Settings")] // ✅ חדש
    public LayerMask robotLayer;           // ✅ שכבת הרובוטים שאתה תבחר

    private bool isReloading = false;
    private bool waitingForReload = false;

    void Start()
    {
        UpdateAmmoUI();
    }

    void Update()
    {
        if (Input.GetMouseButton(0) && Time.time >= nextFireTime && !isReloading && currentAmmo > 0)
        {
            nextFireTime = Time.time + fireRate;
            FireTriple();
            shotsFired++;

            if (shootAnimationObject != null)
                StartCoroutine(PlayShootAnimation());

            if (shotsFired >= 2 && !waitingForReload)
            {
                waitingForReload = true;
                StartCoroutine(Reload());
            }
        }
    }

    void FireTriple()
    {
        if (currentAmmo <= 0)
            return;

        ShootBullet(firePoint.position, firePoint.rotation);
        ShootBullet(firePoint.position, firePoint.rotation * Quaternion.Euler(0f, -spreadAngle, 0f));
        ShootBullet(firePoint.position, firePoint.rotation * Quaternion.Euler(0f, spreadAngle, 0f));

        if (shootAudioSource != null && shootSoundClip != null)
        {
            shootAudioSource.PlayOneShot(shootSoundClip);
        }

        if (muzzleFlash != null)
        {
            muzzleFlash.Play();
        }

        currentAmmo--;

        UpdateAmmoUI();
    }

    void ShootBullet(Vector3 position, Quaternion rotation)
    {
        GameObject bullet = Instantiate(bulletPrefab, position, rotation, bulletContainer);

        Rigidbody rb = bullet.GetComponent<Rigidbody>();
        if (rb != null)
        {
            rb.isKinematic = true;
            rb.useGravity = false;
        }

        Bullet4 bulletScript = bullet.GetComponent<Bullet4>();
        if (bulletScript != null)
        {
            bulletScript.SetStartPosition(position);
        }

        StartCoroutine(MoveAndDestroy(bullet, position));
    }

    IEnumerator MoveAndDestroy(GameObject bullet, Vector3 startPosition)
    {
        float timer = 0f;

        while (bullet != null)
        {
            bullet.transform.position += bullet.transform.forward * bulletSpeed * Time.deltaTime;

            Vector3 up = bullet.transform.up;
            float offset = Mathf.Sin(timer * twistFrequency * 2f * Mathf.PI) * twistAmount;
            bullet.transform.position += up * offset * Time.deltaTime;

            float distance = Vector3.Distance(startPosition, bullet.transform.position);
            if (distance >= bulletMaxDistance)
            {
                Destroy(bullet);
                yield break;
            }

            timer += Time.deltaTime;
            yield return null;
        }
    }

    IEnumerator PlayShootAnimation()
    {
        Quaternion startRotation = shootAnimationObject.localRotation;
        Quaternion recoilRotation = startRotation * Quaternion.Euler(0f, recoilAngle, 0f);

        float elapsed = 0f;

        while (elapsed < recoilDuration)
        {
            float t = elapsed / recoilDuration;
            shootAnimationObject.localRotation = Quaternion.Slerp(startRotation, recoilRotation, t);
            elapsed += Time.deltaTime;
            yield return null;
        }

        shootAnimationObject.localRotation = recoilRotation;

        elapsed = 0f;

        while (elapsed < recoilDuration)
        {
            float t = elapsed / recoilDuration;
            shootAnimationObject.localRotation = Quaternion.Slerp(recoilRotation, startRotation, t);
            elapsed += Time.deltaTime;
            yield return null;
        }

        shootAnimationObject.localRotation = startRotation;
    }

    IEnumerator Reload()
    {
        isReloading = true;

        if (reloadAudioSource != null && reloadSoundClip != null)
        {
            reloadAudioSource.PlayOneShot(reloadSoundClip);
        }

        if (reloadAnimationObject != null)
        {
            Vector3 startPosition = reloadAnimationObject.localPosition;
            Vector3 backPosition = startPosition + new Vector3(-reloadDistance, 0f, 0f);

            float elapsed = 0f;

            while (elapsed < reloadDuration)
            {
                float t = elapsed / reloadDuration;
                reloadAnimationObject.localPosition = Vector3.Lerp(startPosition, backPosition, t);
                elapsed += Time.deltaTime;
                yield return null;
            }

            reloadAnimationObject.localPosition = backPosition;

            elapsed = 0f;

            while (elapsed < reloadDuration)
            {
                float t = elapsed / reloadDuration;
                reloadAnimationObject.localPosition = Vector3.Lerp(backPosition, startPosition, t);
                elapsed += Time.deltaTime;
                yield return null;
            }

            reloadAnimationObject.localPosition = startPosition;
        }

        if (magazines > 0)
        {
            magazines--;
            currentAmmo = maxAmmoPerMagazine;
        }
        else
        {
            currentAmmo = 0;
        }

        UpdateAmmoUI();

        shotsFired = 0;
        isReloading = false;
        waitingForReload = false;
    }

    public void AddMagazines(int amount)
    {
        magazines += amount;
        UpdateAmmoUI();
    }

    void UpdateAmmoUI()
    {
        if (ammoText != null)
        {
            ammoText.text = currentAmmo + " / " + magazines;
        }
    }

    // ✅ פונקציה לזהות אם רובוט הושמד לפי שכבה
    public void OnObjectDestroyed(GameObject destroyedObject)
    {
        if (((1 << destroyedObject.layer) & robotLayer) != 0)
        {
            AddMagazines(2);
        }
    }
}

using UnityEngine;
using UnityEngine.AI;
using System.Collections;

public class GorillaEnemyAI : MonoBehaviour
{
    [Header("Chase Settings")]
    public float chaseRange = 20f, walkRange = 8f, attackRange = 2f, stopDistance = 1.5f;
    public float runSpeed = 6f, walkSpeed = 3.5f, idleSpeed = 1.5f;
    [Range(1, 99)] public int avoidancePriority = 50;
    public string targetTag = "Player";

    [Header("Rotation & References")]
    [SerializeField] private float rotationSpeed = 5f;
    [SerializeField] private Animator animator;
    public GorillaHealth gorillaHealth;
    public Transform resumePoint;

    private NavMeshAgent agent;
    private Transform player;

    private float attackCooldown = 2.3f, lastAttackTime = -Mathf.Infinity;
    private int lastAttackIndex = -1;
    [HideInInspector] public bool isInvulnerable = false;

    private GameObject[] bots;
    private Transform randomBotTarget;
    [Range(0f, 1f)] public float botEngageChance = 0.25f;
    private float botCheckCooldown = 2f, lastBotCheckTime = -999f;
    private bool isAttackingBot = false;

    [Header("Swing Settings")]
    public Transform[] swingPoints;
    public Transform swingStartPoint;
    public float swingTriggerDistance = 8f, swingSpeed = 2f, swingHeight = 4f, approachSpeed = 6f;

    private int currentSwingIndex = 0;
    private bool isSwinging = false, preparingToSwing = false, triggeredSwing = false, finishedSwing = false;
    private float swingProgress = 0f;
    private Vector3 swingStart, swingEnd;

    private bool waitingForPlayerAfterSwing = false;

    void Start()
    {
        agent = GetComponent<NavMeshAgent>();
        if (!agent) { Debug.LogError("Missing NavMeshAgent!"); enabled = false; return; }

        agent.avoidancePriority = avoidancePriority;
        agent.speed = idleSpeed;
        agent.stoppingDistance = stopDistance;

        if (!animator) animator = GetComponent<Animator>();

        GameObject playerObject = GameObject.FindGameObjectWithTag(targetTag);
        if (playerObject) player = playerObject.transform;
    }

    void Update()
    {
        if (!player || !agent || !gorillaHealth) return;

        // ✅ חזרה לאחר Swing – מחכה לשחקן שיתקרב לפחות מ־25 מטר
        if (finishedSwing)
        {
            float distToPlayer = Vector3.Distance(transform.position, player.position);
            if (!waitingForPlayerAfterSwing)
            {
                waitingForPlayerAfterSwing = true;
                agent.enabled = false;
                SetAnimationState(false, false, true); // מצב עמידה
            }

            if (distToPlayer < 35f)
            {
                agent.enabled = true;
                agent.SetDestination(player.position);
                SetAnimationState(true, false, false);
                finishedSwing = false;
                triggeredSwing = false;
                waitingForPlayerAfterSwing = false;
            }

            return;
        }

        // התחלת Swing
        if (!triggeredSwing && gorillaHealth.CurrentHealth <= gorillaHealth.maxHealth * 0.3f && swingStartPoint != null)
        {
            triggeredSwing = true;
            agent.speed = runSpeed;
            agent.SetDestination(swingStartPoint.position);
            SetAnimationState(true, false, false);
            StartCoroutine(TempInvulnerability());
            return;
        }

        // הליכה לנקודת Swing
        if (triggeredSwing && !preparingToSwing && !isSwinging && swingStartPoint != null)
        {
            float dist = Vector3.Distance(transform.position, swingStartPoint.position);
            if (dist > swingTriggerDistance)
            {
                agent.SetDestination(swingStartPoint.position);
                SetAnimationState(false, true, false);
                return;
            }
            else
            {
                BeginSwingApproach();
                return;
            }
        }

        if (HandleSwing()) return;

        if (Time.time - lastBotCheckTime >= botCheckCooldown)
        {
            bots = GameObject.FindGameObjectsWithTag("Bots");
            randomBotTarget = null;

            foreach (var bot in bots)
            {
                if (Vector3.Distance(transform.position, bot.transform.position) <= 10f &&
                    Vector3.Distance(transform.position, player.position) > 12f &&
                    Random.value < botEngageChance)
                {
                    randomBotTarget = bot.transform;
                    break;
                }
            }
            lastBotCheckTime = Time.time;
        }

        Transform target = (randomBotTarget && Random.value < botEngageChance) ? randomBotTarget : player;
        float distance = Vector3.Distance(transform.position, target.position);

        if (distance <= attackRange)
        {
            agent.SetDestination(transform.position);
            agent.velocity = Vector3.zero;

            if (Time.time - lastAttackTime >= attackCooldown)
            {
                bool isBot = target.CompareTag("Bots");
                if (!isBot || (isBot && Random.value < botEngageChance))
                {
                    PlayRandomAttackAnimation();
                    lastAttackTime = Time.time;
                    isAttackingBot = isBot;
                    if (isBot) Invoke(nameof(ReturnToPlayerFocus), 1.5f);
                }
            }

            SetAnimationState(false, false, false);
        }
        else
        {
            agent.speed = (distance <= walkRange) ? walkSpeed : runSpeed;
            agent.SetDestination(target.position);
            SetAnimationState(distance > walkRange, distance <= walkRange, false);
        }

        RotateTowards(isAttackingBot && randomBotTarget ? randomBotTarget : player);
    }

    private bool HandleSwing()
    {
        if (preparingToSwing) { PrepareSwingMovement(); return true; }
        if (isSwinging) { DoArcSwing(); return true; }
        return false;
    }

    private void BeginSwingApproach()
    {
        agent.enabled = false;
        preparingToSwing = true;
        animator.SetTrigger("Swing");
        transform.rotation = Quaternion.identity;
    }

    private void PrepareSwingMovement()
    {
        Vector3 target = swingPoints[0].position;
        transform.position = Vector3.MoveTowards(transform.position, target, approachSpeed * Time.deltaTime);

        if (Vector3.Distance(transform.position, target) < 0.1f)
        {
            preparingToSwing = false;
            StartSwing();
        }
    }

    private void DoArcSwing()
    {
        if (currentSwingIndex >= swingPoints.Length) return;

        swingProgress += Time.deltaTime * swingSpeed;
        Vector3 flatPos = Vector3.Lerp(swingStart, swingEnd, swingProgress);
        float heightOffset = Mathf.Sin(swingProgress * Mathf.PI) * swingHeight;
        transform.position = flatPos + Vector3.up * heightOffset;

        if (swingProgress >= 1f)
        {
            if (++currentSwingIndex >= swingPoints.Length)
                EndSwing();
            else
            {
                swingStart = swingPoints[currentSwingIndex - 1].position;
                swingEnd = swingPoints[currentSwingIndex].position;
                swingProgress = 0f;
            }
        }
    }

    private void StartSwing()
    {
        isSwinging = true;
        currentSwingIndex = 1;
        swingStart = swingPoints[0].position;
        swingEnd = swingPoints[1].position;
        swingProgress = 0f;
    }

    private void EndSwing()
    {
        isSwinging = false;
        preparingToSwing = false;
        finishedSwing = true;

        runSpeed *= 1.5f;
        walkSpeed *= 1.5f;
        idleSpeed *= 1.5f;
        approachSpeed *= 1.5f;
        attackCooldown = 1.5f;

        if (swingStartPoint != null)
        {
            Destroy(swingStartPoint.gameObject);
            swingStartPoint = null;
        }
    }

    private void PlayRandomAttackAnimation()
    {
        int newIndex;
        do { newIndex = Random.Range(0, 3); } while (newIndex == lastAttackIndex);
        lastAttackIndex = newIndex;
        isInvulnerable = true;

        animator.SetTrigger(newIndex switch
        {
            0 => "Attack",
            1 => "Attack2",
            2 => "Attack3",
            _ => "Attack"
        });
    }

    public void EndAttack() => isInvulnerable = false;

    private void RotateTowards(Transform target)
    {
        Vector3 dir = target.position - transform.position;
        dir.y = 0;
        if (dir.magnitude > 0.5f)
            transform.rotation = Quaternion.Slerp(transform.rotation, Quaternion.LookRotation(dir), Time.deltaTime * rotationSpeed);
    }

    private void SetAnimationState(bool run, bool walk, bool idle)
    {
        animator.SetBool("run", run);
        animator.SetBool("walk", walk);
        animator.SetBool("idle", idle);
    }

    private void ReturnToPlayerFocus()
    {
        isAttackingBot = false;
        randomBotTarget = null;
    }

    private IEnumerator TempInvulnerability()
    {
        gorillaHealth.isInvulnerable = true;
        yield return new WaitForSeconds(10f);
        gorillaHealth.isInvulnerable = false;
    }
}

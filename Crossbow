using System.Collections;
using UnityEngine;

public class CrossBow : MonoBehaviour
{
    public float bobDistance = 0.3f;
    public float backwardDuration = 0.4f;
    public float forwardDuration = 0.15f;

    public GameObject arrow;
    public float minArrowSpeed = 20f;
    public float maxArrowSpeed = 40f;
    public float chargeTime = 3f;

    public LayerMask enemyLayer;     // ×©×›×‘×ª ××•×™×‘×™×
    public LayerMask hitLayers;      // ×©×›×‘×•×ª ×©×™×’×¨××• ×œ×—×¥ ×œ×—×–×•×¨ (×—×“×©!)

    private Vector3 initialLocalPosition;
    private Vector3 stretchedPosition;
    private Coroutine moveCoroutine;
    private bool isStretching = false;
    private bool isReturning = false;
    private bool arrowReleased = false;
    private bool arrowFlying = false;
    private float holdTimer = 0f;
    private bool isHolding = false;

    private Vector3 arrowInitialLocalPos;
    private Quaternion arrowInitialLocalRot;

    void Start()
    {
        initialLocalPosition = transform.localPosition;
        stretchedPosition = initialLocalPosition - Vector3.up * bobDistance;

        if (arrow != null)
        {
            arrowInitialLocalPos = arrow.transform.localPosition;
            arrowInitialLocalRot = arrow.transform.localRotation;
        }
    }

    void Update()
    {
        if (Input.GetMouseButtonDown(1))
        {
            if (!isStretching && !isReturning)
            {
                moveCoroutine = StartCoroutine(StretchRope());
                isHolding = true;
                holdTimer = 0f;
            }
        }

        if (Input.GetMouseButton(1) && isHolding)
        {
            holdTimer += Time.deltaTime;

            if (holdTimer >= chargeTime && !arrowReleased)
            {
                isHolding = false;
                StopCoroutine(moveCoroutine);
                isStretching = false;
                StartCoroutine(ReturnRope(transform.localPosition));
            }
        }

        if (Input.GetMouseButtonUp(1))
        {
            if (isHolding)
            {
                isHolding = false;
                if (isStretching)
                {
                    StopCoroutine(moveCoroutine);
                    isStretching = false;
                    StartCoroutine(ReturnRope(transform.localPosition));
                }
                else if (!isReturning && transform.localPosition != initialLocalPosition)
                {
                    StartCoroutine(ReturnRope(transform.localPosition));
                }
            }
        }

        if (arrowFlying && arrow != null)
        {
            float arrowSpeed = CalculateArrowSpeed();
            Vector3 moveDirection = -arrow.transform.up;
            Vector3 moveStep = moveDirection * arrowSpeed * Time.deltaTime;

            // ğŸ” ×‘×“×™×§×” ×× ×”×—×¥ ×¤×•×’×¢ ×‘×©×›×‘×ª ××•×™×‘×™× ×•×’×•×¨× × ×–×§ (×§×™×™×)
            if (Physics.Raycast(arrow.transform.position, moveDirection, out RaycastHit hit, moveStep.magnitude + 0.1f, enemyLayer))
            {
                SimpleEnemyHealth1 health = hit.collider.GetComponent<SimpleEnemyHealth1>();
                if (health != null)
                {
                    health.TakeDamage(100);
                }

                ResetArrow();
            }
            // ğŸ” ×—×“×© â€“ ×¤×•×’×¢ ×‘×›×œ ×©×›×‘×ª hitLayers â†’ ×”×—×–×¨×ª ×”×—×¥
            else if (Physics.Raycast(arrow.transform.position, moveDirection, out RaycastHit hit2, moveStep.magnitude + 0.1f, hitLayers))
            {
                ResetArrow();
            }
            else
            {
                // ×œ× ×¤×’×¢ â€“ ×××©×™×š ×œ×–×•×– ×§×“×™××”
                arrow.transform.position += moveStep;
            }
        }
    }

    float CalculateArrowSpeed()
    {
        float chargeRatio = Mathf.Clamp01(holdTimer / chargeTime);
        return Mathf.Lerp(minArrowSpeed, maxArrowSpeed, chargeRatio);
    }

    IEnumerator StretchRope()
    {
        isStretching = true;
        float elapsed = 0f;
        Vector3 startPos = transform.localPosition;
        Vector3 targetPos = stretchedPosition;

        while (elapsed < backwardDuration)
        {
            float t = elapsed / backwardDuration;
            transform.localPosition = Vector3.Lerp(startPos, targetPos, t);
            elapsed += Time.deltaTime;
            yield return null;
        }

        transform.localPosition = targetPos;
        isStretching = false;
    }

    IEnumerator ReturnRope(Vector3 fromPosition)
    {
        isReturning = true;

        if (arrow != null && !arrowReleased)
        {
            arrowReleased = true;
            arrow.transform.parent = null;

            Rigidbody rb = arrow.GetComponent<Rigidbody>();
            if (rb != null)
                rb.isKinematic = true;

            arrowFlying = true;
        }

        float elapsed = 0f;
        while (elapsed < forwardDuration)
        {
            float t = elapsed / forwardDuration;
            transform.localPosition = Vector3.Lerp(fromPosition, initialLocalPosition, t);
            elapsed += Time.deltaTime;
            yield return null;
        }

        transform.localPosition = initialLocalPosition;
        isReturning = false;
    }

    void ResetArrow()
    {
        arrowFlying = false;
        arrowReleased = false;

        arrow.transform.parent = transform;
        arrow.transform.localPosition = arrowInitialLocalPos;
        arrow.transform.localRotation = arrowInitialLocalRot;
    }

    void OnDrawGizmosSelected()
    {
        if (arrow != null)
        {
            Gizmos.color = Color.red;
            Gizmos.DrawLine(arrow.transform.position, arrow.transform.position + (-arrow.transform.up * 1f));
        }
    }
}

using UnityEngine;
using System.Collections;

public class EnemyHealth100 : MonoBehaviour
{
    public int maxHealth = 100;
    private int currentHealth;

    [Header("Destroyed Version")]
    public GameObject destroyedVersion; // הגרסה שתופיע במקום האויב כשהוא מת

    [Header("Hit Reaction")]
    public Transform hitReactionObject; // האובייקט שיסתובב כשמקבל נזק
    public float rotationAmountZ = 90f; // כמה מעלות יסתובב
    public float rotationDuration = 0.15f; // כמה זמן ייקח כל כיוון

    [Header("Hit Sound")]
    public AudioClip hitSound;
    public AudioSource audioSource;

    private bool isRotating = false;
    private bool isAlternateDirection = false; // בודק אם זאת הפעם השנייה, רביעית וכו'

    void Start()
    {
        currentHealth = maxHealth;
    }

    public void TakeDamage(int amount)
    {
        currentHealth -= amount;

        // השמעת סאונד פגיעה אם הוגדר
        if (hitSound != null && audioSource != null)
        {
            audioSource.PlayOneShot(hitSound);
        }

        // ריאקציית סיבוב אם יש אובייקט מוגדר ולא באמצע תנועה
        if (hitReactionObject != null && !isRotating)
        {
            StartCoroutine(RotateOnHit());
        }

        if (currentHealth <= 0)
        {
            Die();
        }
    }

    void Die()
    {
        if (destroyedVersion != null)
        {
            Instantiate(destroyedVersion, transform.position, transform.rotation);
        }

        Destroy(gameObject);
    }

    IEnumerator RotateOnHit()
    {
        isRotating = true;

        // קובע אם צריך לסובב קדימה או אחורה
        float actualRotationZ = isAlternateDirection ? -rotationAmountZ : rotationAmountZ;

        Quaternion initialRotation = hitReactionObject.localRotation;
        Quaternion targetRotation = initialRotation * Quaternion.Euler(0, 0, actualRotationZ);

        float t = 0f;
        while (t < rotationDuration)
        {
            hitReactionObject.localRotation = Quaternion.Slerp(initialRotation, targetRotation, t / rotationDuration);
            t += Time.deltaTime;
            yield return null;
        }

        hitReactionObject.localRotation = targetRotation;

        t = 0f;
        while (t < rotationDuration)
        {
            hitReactionObject.localRotation = Quaternion.Slerp(targetRotation, initialRotation, t / rotationDuration);
            t += Time.deltaTime;
            yield return null;
        }

        hitReactionObject.localRotation = initialRotation;
        isRotating = false;

        // הפוך את הכיוון לפעם הבאה
        isAlternateDirection = !isAlternateDirection;
    }
}
